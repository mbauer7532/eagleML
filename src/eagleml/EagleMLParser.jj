options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(EagleMLParser)

package eagleml;

import java.util.List;
import java.util.LinkedList;
import java.util.Deque;
import java.util.ArrayDeque;
import eagleml.EagleMLAst.*;
import static eagleml.EagleMLAst.*;

final public class EagleMLParser {
  public void initExpressionStacks() {
    m_operators = new ArrayDeque<Operator>();
    m_operands  = new ArrayDeque<ExprAst>();

    return;
  }

  private void popOperator() {
    final Operator oper = m_operators.pop();

    if (oper.isBinary()) {
      final ExprAst t1 = m_operands.pop();
      final ExprAst t0 = m_operands.pop();

      m_operands.push(BinOper.create(t0, oper, t1));
    }
    else if (oper.isUnary()) {
      final ExprAst t0 = m_operands.pop();
      m_operands.push(UnaryOper.create(oper, t0));
    }
    else
    {
      throw new RuntimeException("Bad operator.");
    }

    return;
  }

  private void pushOperator(final Operator oper) {
    while (m_operators.peek().greaterPrecedence(oper)) {
      popOperator();
    }
    m_operators.push(oper);

    return;
  }

  private Deque<Operator> m_operators;
  private Deque<ExprAst> m_operands;
}

PARSER_END(EagleMLParser)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < BOOLEAN: "bool" >
| < INT: "int" >
| < TRUE: "true" >
| < FALSE: "false" >
| < IF: "if" >
| < ELSE: "else" >
| < DEF: "def" >
| < LET: "let" >
| < IN: "in" >
| < END: "end" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
| < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| < #OCTAL_LITERAL: "0" (["0"-"7"])* >
| < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'" >
| < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\"" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
| < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ] >
| < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ] >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN:    "(" >
| < RPAREN:    ")" >
| < LBRACE:    "{" >
| < RBRACE:    "}" >
| < LBRACKET:  "[" >
| < RBRACKET:  "]" >
| < SEMICOLON: ";" >
| < COMMA:     "," >
| < DOT:       "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN:               "=" >
| < GT:                   ">" >
| < LT:                   "<" >
| < BANG:                 "!" >
| < TILDE:                "~" >
| < QUESTION_MARK:        "?" >
| < COLON:                ":" >
| < EQ:                   "==" >
| < NEQ:                  "!=" >
| < LEQ:                  "<=" >
| < GEQ:                  ">=" >
| < SC_OR:                "||" >
| < SC_AND:               "&&" >
| < PLUS:                 "+" >
| < MINUS:                "-" >
| < TIMES:                "*" >
| < DIVIDE:               "/" >
| < BIT_AND:              "&" >
| < BIT_OR:               "|" >
| < XOR:                  "^" >
| < REM:                  "%" >
| < LSHIFT:               "<<" >
| < RIGHT_SIGNED_SHIFT:   ">>" >
| < RIGHT_UNSIGNED_SHIFT: ">>>" >
}

/*****************************************
 * THE NEO LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

List<Def> CompilationUnit() :
{
  List<Def> defList = new LinkedList<Def>();
  FunDef def;
}
{
  (def = FunctionDefinition() { defList.add(def); } )+ <EOF> { return defList; }
}

FunDef FunctionDefinition() :
{
   String funName;
   List<TypedVar> tyVars;
   ExprAst expr;
   EagleMLType funType = null;
}
{
    <DEF>
    <IDENTIFIER> { funName = token.image; }
    <LPAREN>
    (tyVars = FunArgs())
    <RPAREN>
    [funType = Type()]
    <ASSIGN>
   (expr = Expr()) { return FunDef.create(funName, tyVars, funType, expr); }
}

List<TypedVar> FunArgs() :
{
  TypedVar typedVar;
  List<TypedVar> typedVars = new LinkedList<TypedVar>();
}
{
  [ typedVar = FormalParameter() { typedVars.add(typedVar); }
    (<COMMA> typedVar = FormalParameter() { typedVars.add(typedVar); })*]
  { return typedVars; }
}

TypedVar FormalParameter() :
{
  EagleMLType typ;
  String name;
}
{
  (typ = Type() <IDENTIFIER> { name = token.image; }) { return TypedVar.create(name, typ); }
}

EagleMLType Type() :
{
  EagleMLType typ;
}
{
  (<INT>       { typ = makeIntType(); }
   | <BOOLEAN> { typ = makeBoolType(); })
  { return typ; }
}

/*
 * Expression syntax follows.
 */

ExprAst Expr() :
{}
{
  { m_operators.push(Operator.NO_OPPER); }
  ExprAstAux()
  {
    ExprAst res = m_operands.pop();
    m_operators.pop(); // Get rid of the sentinel.

    assert m_operands.size() == 0: "The expression operands array was not empty at the end of an expression parse.";
    assert m_operators.size() == 0: "The expression operators array was not empty at the end of an expression parse.";

    return res;
  }
}

void ExprAstAux() :
{
  Operator oper;
}
{
  (P()
   (oper = BinaryOperator() { pushOperator(oper); } P())*)
  {
    while (! m_operators.peek().isNoOper())
    {
      popOperator();
    }
  }
}

void P() :
{
  ExprAst t;
  Operator unary;
}
{
  <LPAREN> { m_operators.push(Operator.NO_OPPER); }
  Expr()
  <RPAREN> { m_operators.pop(); }
  | t = Literal()
    {
      m_operands.push(t);
    }
  | <IDENTIFIER>
    {
      m_operands.push(VarRef.create(token.image));
    }
  | unary = UnaryOperator() { m_operators.push(unary); } P()
}

ExprAst Literal() :
{
  ExprAst expr;
}
{
  (expr = IntegerLiteral()
   | expr = BooleanLiteral())
 { return expr; }
}

ExprAst IntegerLiteral() :
{}
{
  <INTEGER_LITERAL> { return IntLit.create(Integer.parseInt(token.image)); }
}

ExprAst BooleanLiteral() :
{
  ExprAst boolLit;
}
{
  (<TRUE>  { boolLit = BoolLit.create(true); }
   | <FALSE> { boolLit = BoolLit.create(false); })
 { return boolLit; }
}

Operator BinaryOperator() :
{
  Operator oper;
}
{
  (<SC_OR>  { oper = Operator.OR; }
   | <SC_AND> { oper = Operator.AND; }

   | <LT>     { oper = Operator.LT; }
   | <GT>     { oper = Operator.GT; }
   | <LEQ>    { oper = Operator.LEQ; }
   | <GEQ>    { oper = Operator.GEQ; }
   | <EQ>     { oper = Operator.EQ; }
   | <NEQ>    { oper = Operator.NEQ; }

   | <PLUS>   { oper = Operator.PLUS; }
   | <MINUS>  { oper = Operator.MINUS; }
   | <TIMES>  { oper = Operator.TIMES; }
   | <DIVIDE> { oper = Operator.DIVIDE; }
   | <REM>    { oper = Operator.REM; }
   | <XOR>    { oper = Operator.XOR; })
  {
    return oper;
  }
}

Operator UnaryOperator() :
{
  Operator oper;
}
{
  (<PLUS>  { oper = Operator.UPLUS; }
   | <MINUS> { oper = Operator.UMINUS; })
  {
    return oper;
  }
}
