options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(NeoMLParser)

import java.util.Map;
import java.util.List;
import java.util.HashMap;
import java.util.LinkedList;

final public class NeoMLParser {

  public class NeoMLType {}
  final static public class TypedVar {
    static TypedVar create(String name, NeoMLType typ) {
      return new TypedVar();
    }
  }

  public NeoMLType makeIntType() { return new NeoMLType(); }
  public NeoMLType makeBoolType() { return new NeoMLType(); }

  public class ExprAst {};

  final static public class IntLit extends ExprAst {
    public static IntLit create(String intStr) {
      return null;
    }
  };

  final static public class BoolLit extends ExprAst {
    public static BoolLit create(boolean b) {
      return null;
    }
  };

  final static public class VarRef extends ExprAst {
    public static VarRef create(String varName) {
      return null;
    }
  };

  final static public class BinOper extends ExprAst {
    public static BinOper create(ExprAst t1, String oper, ExprAst t2) {
      return null;
    }
  };

  public class Def {};

  final static public class FunDef extends Def
  {
    static FunDef create(String funName, List<TypedVar> tyVars, NeoMLType funType, ExprAst expr) {
      return new FunDef();
    }
  };

  final static public class VarDef extends Def {
    static VarDef create() {
      return null;
    }
  };

  enum OperAssociativity {
    LEFT,
    RIGHT,
    NOASSOC
  };

  enum ////////////////////////////////////////////////////////


  final static class OperInfo {
    public static OperInfo create(int precedence, OperAssociativity associativity) {
      return new OperInfo(precedence, associativity);
    }

    public int getPrecedence() { return m_precedence; }
    public OperAssociativity getAssociativity() { return m_associativity; }

    private OperInfo(int precedence, OperAssociativity associativity)
    {
      m_precedence = precedence;
      m_associativity = associativity;
    }

    private int m_precedence;
    private OperAssociativity m_associativity;
  };

  final static Map<String, OperInfo> precedenceOperMap;
  static {
    precedenceOperMap = new HashMap<String, OperInfo>();

    precedenceOperMap.put("||", OperInfo.create(0, OperAssociativity.LEFT));
    precedenceOperMap.put("&&", OperInfo.create(1, OperAssociativity.LEFT));

    precedenceOperMap.put("<", OperInfo.create(2, OperAssociativity.NOASSOC));
    precedenceOperMap.put(">", OperInfo.create(2, OperAssociativity.NOASSOC));
    precedenceOperMap.put("<=", OperInfo.create(2, OperAssociativity.NOASSOC));
    precedenceOperMap.put(">=", OperInfo.create(2, OperAssociativity.NOASSOC));
    precedenceOperMap.put("==", OperInfo.create(2, OperAssociativity.NOASSOC));
    precedenceOperMap.put("!=", OperInfo.create(2, OperAssociativity.NOASSOC));

    precedenceOperMap.put("+",  OperInfo.create(3, OperAssociativity.LEFT));
    precedenceOperMap.put("-",  OperInfo.create(3, OperAssociativity.LEFT));
    precedenceOperMap.put("*",  OperInfo.create(4, OperAssociativity.LEFT));
    precedenceOperMap.put("/",  OperInfo.create(4, OperAssociativity.LEFT));
    precedenceOperMap.put("%",  OperInfo.create(4, OperAssociativity.LEFT));
    precedenceOperMap.put("^",  OperInfo.create(5, OperAssociativity.LEFT));
  }

  public static void main(String args[]) {
    NeoMLParser parser;
    if (args.length == 0) {
      System.out.println("Java Parser Version 1.0.2:  Reading from standard input . . .");
      parser = new NeoMLParser(System.in);
    } else if (args.length == 1) {
      System.out.println("Java Parser Version 1.0.2:  Reading from file " + args[0] + " . . .");
      try {
        parser = new NeoMLParser(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Java Parser Version 1.0.2:  File " + args[0] + " not found.");
        return;
      }
    } else {
      System.out.println("Java Parser Version 1.0.2:  Usage is one of:");
      System.out.println("         java NeoMLParser < inputfile");
      System.out.println("OR");
      System.out.println("         java NeoMLParser inputfile");
      return;
    }
    try {
      parser.CompilationUnit();
      System.out.println("Java Parser Version 1.0.2:  Java program parsed successfully.");
    } catch (ParseException e) {
      System.out.println("Java Parser Version 1.0.2:  Encountered errors during parse.");
    }
  }

}

PARSER_END(NeoMLParser)


SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < BOOLEAN: "bool" >
| < INT: "int" >
| < TRUE: "true" >
| < FALSE: "false" >
| < IF: "if" >
| < ELSE: "else" >
| < DEF: "def" >
| < LET: "let" >
| < IN: "in" >
| < END: "end" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
| < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| < #OCTAL_LITERAL: "0" (["0"-"7"])* >
| < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'" >
| < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\"" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
| < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ] >
| < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ] >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN:    "(" >
| < RPAREN:    ")" >
| < LBRACE:    "{" >
| < RBRACE:    "}" >
| < LBRACKET:  "[" >
| < RBRACKET:  "]" >
| < SEMICOLON: ";" >
| < COMMA:     "," >
| < DOT:       "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN:               "=" >
| < GT:                   ">" >
| < LT:                   "<" >
| < BANG:                 "!" >
| < TILDE:                "~" >
| < QUESTION_MARK:        "?" >
| < COLON:                ":" >
| < EQ:                   "==" >
| < NEQ:                  "!=" >
| < LEQ:                  "<=" >
| < GEQ:                  ">=" >
| < SC_OR:                "||" >
| < SC_AND:               "&&" >
| < PLUS:                 "+" >
| < MINUS:                "-" >
| < TIMES:                "*" >
| < DIVIDE:               "/" >
| < BIT_AND:              "&" >
| < BIT_OR:               "|" >
| < XOR:                  "^" >
| < REM:                  "%" >
| < LSHIFT:               "<<" >
| < RIGHT_SIGNED_SHIFT:   ">>" >
| < RIGHT_UNSIGNED_SHIFT: ">>>" >
}

/*****************************************
 * THE NEO LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

List<Def> CompilationUnit() :
{
  List<Def> defList = new LinkedList<Def>();
  FunDef def;
}
{
  (def = FunctionDefinition() { defList.add(def); } )+ <EOF> { return defList; }
}

FunDef FunctionDefinition() :
{
   String funName;
   List<TypedVar> tyVars;
   ExprAst expr;
   NeoMLType funType = null;
}
{
    <DEF>
    <IDENTIFIER> { funName = token.image; }
    <LPAREN>
    (tyVars = FunArgs())
    <RPAREN>
    [funType = Type()]
    <ASSIGN>
   (expr = Expr(0)) { return FunDef.create(funName, tyVars, funType, expr); }
}

List<TypedVar> FunArgs() :
{
  TypedVar typedVar;
  List<TypedVar> typedVars = new LinkedList<TypedVar>();
}
{
  [ typedVar = FormalParameter() { typedVars.add(typedVar); }
    (<COMMA> typedVar = FormalParameter() { typedVars.add(typedVar); })*]
  { return typedVars; }
}

TypedVar FormalParameter() :
{
  NeoMLType typ;
  String name;
}
{
  (typ = Type() <IDENTIFIER> { name = token.image; }) { return TypedVar.create(name, typ); }
}

NeoMLType Type() :
{}
{
  <INT>       { return makeIntType(); }
  | <BOOLEAN> { return makeBoolType(); }
}

/*
 * Expression syntax follows.
 */

ExprAst Expr(int p) :
{
  ExprAst t1, t2;
  String oper;
  int q;
}
{
  (t1 = P()
   (oper = BinaryOperator() { { OperInfo operInfo = precedenceOperMap.get(oper);
                                int prec = operInfo.getPrecedence();
                                if (prec < p) {
                                  return t1;
                                }
                                else
                                {
                                  switch (operInfo.getAssociativity())
                                  {
                                  case LEFT:
                                  {
                                    q = prec + 1;
                                    break;
                                  }
                                  case RIGHT:
                                  {
                                    q = prec;
                                    break;
                                  }
                                  case NOASSOC:
                                  { // For now -- the error is detected later during typechecking
                                    q = prec + 1;
                                    break;
                                  }
                                  }
                                } } }
     t2 = Expr(q) { t1 =  BinOper.create( t1, oper, t2); })*)
  { return t1; }
}

ExprAst P() :
{
  ExprAst t;
}
{
  <LPAREN> t = Expr(0) <RPAREN> { return t; }
| t = Literal()                 { return t; }
| <IDENTIFIER>                  { return VarRef.create(token.image); }
}

ExprAst Literal() :
{
  ExprAst expr;
}
{
  expr = IntegerLiteral() { return expr; }
|
  expr = BooleanLiteral() { return expr; }
}

ExprAst IntegerLiteral() :
{}
{
  <INTEGER_LITERAL> { IntLit.create(token.image); }
}

ExprAst BooleanLiteral() :
{}
{
  <TRUE>  { return BoolLit.create(true); }
| <FALSE> { return BoolLit.create(false); }
}

String BinaryOperator() :
{}
{
  <SC_OR> { return ; }
| <SC_AND>
| <PLUS>
| <MINUS>
| <TIMES>
| <DIVIDE>
| <REM>
| <XOR>
| <LT>
| <GT>
| <LEQ>
| <GEQ>
| <EQ>
| <NEQ> { return token.image; }
}
