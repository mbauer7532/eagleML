options {
  JAVA_UNICODE_ESCAPE = true;
  STATIC = false;
}

PARSER_BEGIN(EagleMLParser)

package eagleml;

import java.util.List;
import java.util.LinkedList;
import eagleml.EagleMLAst.*;
import static eagleml.EagleMLAst.*;

final public class EagleMLParser {}

PARSER_END(EagleMLParser)


SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN : /* RESERVED WORDS AND LITERALS */
{
  < BOOLEAN: "bool" >
| < INT: "int" >
| < TRUE: "true" >
| < FALSE: "false" >
| < IF: "if" >
| < ELSE: "else" >
| < DEF: "def" >
| < LET: "let" >
| < IN: "in" >
| < END: "end" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL:
        <DECIMAL_LITERAL> (["l","L"])?
      | <HEX_LITERAL> (["l","L"])?
      | <OCTAL_LITERAL> (["l","L"])?
  >
| < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| < #OCTAL_LITERAL: "0" (["0"-"7"])* >
| < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])?
      | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])?
      | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])?
      | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < CHARACTER_LITERAL:
      "'"
      (   (~["'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )
      "'" >
| < STRING_LITERAL:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
      )*
      "\"" >
}

TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
| < #LETTER:
      [
       "\u0024",
       "\u0041"-"\u005a",
       "\u005f",
       "\u0061"-"\u007a",
       "\u00c0"-"\u00d6",
       "\u00d8"-"\u00f6",
       "\u00f8"-"\u00ff",
       "\u0100"-"\u1fff",
       "\u3040"-"\u318f",
       "\u3300"-"\u337f",
       "\u3400"-"\u3d2d",
       "\u4e00"-"\u9fff",
       "\uf900"-"\ufaff"
      ] >
| < #DIGIT:
      [
       "\u0030"-"\u0039",
       "\u0660"-"\u0669",
       "\u06f0"-"\u06f9",
       "\u0966"-"\u096f",
       "\u09e6"-"\u09ef",
       "\u0a66"-"\u0a6f",
       "\u0ae6"-"\u0aef",
       "\u0b66"-"\u0b6f",
       "\u0be7"-"\u0bef",
       "\u0c66"-"\u0c6f",
       "\u0ce6"-"\u0cef",
       "\u0d66"-"\u0d6f",
       "\u0e50"-"\u0e59",
       "\u0ed0"-"\u0ed9",
       "\u1040"-"\u1049"
      ] >
}

TOKEN : /* SEPARATORS */
{
  < LPAREN:    "(" >
| < RPAREN:    ")" >
| < LBRACE:    "{" >
| < RBRACE:    "}" >
| < LBRACKET:  "[" >
| < RBRACKET:  "]" >
| < SEMICOLON: ";" >
| < COMMA:     "," >
| < DOT:       "." >
}

TOKEN : /* OPERATORS */
{
  < ASSIGN:               "=" >
| < GT:                   ">" >
| < LT:                   "<" >
| < BANG:                 "!" >
| < TILDE:                "~" >
| < QUESTION_MARK:        "?" >
| < COLON:                ":" >
| < EQ:                   "==" >
| < NEQ:                  "!=" >
| < LEQ:                  "<=" >
| < GEQ:                  ">=" >
| < SC_OR:                "||" >
| < SC_AND:               "&&" >
| < PLUS:                 "+" >
| < MINUS:                "-" >
| < TIMES:                "*" >
| < DIVIDE:               "/" >
| < BIT_AND:              "&" >
| < BIT_OR:               "|" >
| < XOR:                  "^" >
| < REM:                  "%" >
| < LSHIFT:               "<<" >
| < RIGHT_SIGNED_SHIFT:   ">>" >
| < RIGHT_UNSIGNED_SHIFT: ">>>" >
}

/*****************************************
 * THE NEO LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

List<Def> CompilationUnit() :
{
  List<Def> defList = new LinkedList<Def>();
  FunDef def;
}
{
  (def = FunctionDefinition() { defList.add(def); } )+ <EOF> { return defList; }
}

FunDef FunctionDefinition() :
{
   String funName;
   List<TypedVar> tyVars;
   ExprAst expr;
   EagleMLType funType = null;
}
{
    <DEF>
    <IDENTIFIER> { funName = token.image; }
    <LPAREN>
    (tyVars = FunArgs())
    <RPAREN>
    [funType = Type()]
    <ASSIGN>
   (expr = Expr(0)) { return FunDef.create(funName, tyVars, funType, expr); }
}

List<TypedVar> FunArgs() :
{
  TypedVar typedVar;
  List<TypedVar> typedVars = new LinkedList<TypedVar>();
}
{
  [ typedVar = FormalParameter() { typedVars.add(typedVar); }
    (<COMMA> typedVar = FormalParameter() { typedVars.add(typedVar); })*]
  { return typedVars; }
}

TypedVar FormalParameter() :
{
  EagleMLType typ;
  String name;
}
{
  (typ = Type() <IDENTIFIER> { name = token.image; }) { return TypedVar.create(name, typ); }
}

EagleMLType Type() :
{
  EagleMLType typ;
}
{
  (<INT>       { typ = makeIntType(); }
   | <BOOLEAN> { typ = makeBoolType(); })
  { return typ; }
}

/*
 * Expression syntax follows.
 */

ExprAst Expr(int p) :
{
  ExprAst t1, t2;
  Operator oper;
  int q = 0; // Just to get rid of javac warnings.
}
{
  (t1 = P()
   (LOOKAHEAD(1) oper = BinaryOperator() { { final int prec = oper.getPrecedence();
                                if (prec < p) {
                                  return t1;
                                }
                                else
                                {
                                  switch (oper.getAssociativity())
                                  {
                                  case LEFT:
                                  {
                                    q = prec + 1;
                                    break;
                                  }
                                  case RIGHT:
                                  {
                                    q = prec;
                                    break;
                                  }
                                  case NOASSOC:
                                  { // For now -- the error is detected later during typechecking
                                    q = prec + 1;
                                    break;
                                  }
                                  }
                                } } }
     t2 = Expr(q) { t1 =  BinOper.create( t1, oper, t2); })*)
  { return t1; }
}

ExprAst P() :
{
  ExprAst t;
}
{
  (<LPAREN> t = Expr(0) <RPAREN>
   | t = Literal()
   | <IDENTIFIER> { t = VarRef.create(token.image); })
 { return t; }
}

ExprAst Literal() :
{
  ExprAst expr;
}
{
  (expr = IntegerLiteral()
   | expr = BooleanLiteral())
 { return expr; }
}

ExprAst IntegerLiteral() :
{}
{
  <INTEGER_LITERAL> { return IntLit.create(token.image); }
}

ExprAst BooleanLiteral() :
{
  ExprAst boolLit;
}
{
  (<TRUE>  { boolLit = BoolLit.create(true); }
   | <FALSE> { boolLit = BoolLit.create(false); })
 { return boolLit; }
}

Operator BinaryOperator() :
{
  Operator oper;
}
{
  (<SC_OR>  { oper = Operator.OR; }
   | <SC_AND> { oper = Operator.AND; }

   | <LT>     { oper = Operator.LT; }
   | <GT>     { oper = Operator.GT; }
   | <LEQ>    { oper = Operator.LEQ; }
   | <GEQ>    { oper = Operator.GEQ; }
   | <EQ>     { oper = Operator.EQ; }
   | <NEQ>    { oper = Operator.NEQ; }

   | <PLUS>   { oper = Operator.PLUS; }
   | <MINUS>  { oper = Operator.MINUS; }
   | <TIMES>  { oper = Operator.TIMES; }
   | <DIVIDE> { oper = Operator.DIVIDE; }
   | <REM>    { oper = Operator.REM; }
   | <XOR>    { oper = Operator.XOR; })
  { return oper; }
}
